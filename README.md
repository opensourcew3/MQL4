# MQL4 session indicater code 1.1
//+------------------------------------------------------------------+
//|                                                    SessionTimes.mq4|
//|                        Generated by MT4 Indicator and EA Generator|
//|                                      For automatic session display|
//+------------------------------------------------------------------+
#property copyright "YourName"
#property version   "1.07"
#property indicator_chart_window

// Input parameters
input color TokyoColor = clrAqua;         // Tokyo Session Color
input color LondonColor = clrGreen;       // London Session Color
input color NewYorkColor = clrRed;        // New York Session Color
input color OverlapColor = clrSilver;     // Overlapping Sessions Color

input int TokyoStart = 0;                 // Tokyo Start Hour (Broker Time)
input int TokyoEnd = 9;                   // Tokyo End Hour (Broker Time)
input int LondonStart = 8;                // London Start Hour (Broker Time)
input int LondonEnd = 17;                 // London End Hour (Broker Time)
input int NewYorkStart = 13;              // New York Start Hour (Broker Time)
input int NewYorkEnd = 22;                // New York End Hour (Broker Time)

input bool EnableDST = true;              // Enable Daylight Saving Time Adjustment
input bool ShowLabels = true;             // Display Session Names
input int LineWidth = 1;                  // Line Width
input int LookbackDays = 30;              // Number of past days to display

datetime DSTStart;                        // Daylight Saving Time Start
datetime DSTEnd;                          // Daylight Saving Time End

datetime lastUpdateDay = 0;               // Track last updated day

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
  {
   RemoveSessionObjects();  // Clear any existing session objects
   InitializeSessions();    // Draw initial sessions
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Initialize Sessions                                              |
//+------------------------------------------------------------------+
void InitializeSessions()
  {
   int adjustedTokyoStart = TokyoStart;
   int adjustedTokyoEnd = TokyoEnd;
   int adjustedLondonStart = LondonStart;
   int adjustedLondonEnd = LondonEnd;
   int adjustedNewYorkStart = NewYorkStart;
   int adjustedNewYorkEnd = NewYorkEnd;

   // Adjust times for DST if enabled
   if (EnableDST)
     {
      int adjustment = TimeDSTAdjustment();
      adjustedTokyoStart += adjustment;
      adjustedTokyoEnd += adjustment;
      adjustedLondonStart += adjustment;
      adjustedLondonEnd += adjustment;
      adjustedNewYorkStart += adjustment;
      adjustedNewYorkEnd += adjustment;
     }

   // Draw session rectangles for past days
   for (int i = 0; i < LookbackDays; i++)
     {
      datetime dayStart = iTime(Symbol(), PERIOD_D1, i);

      // Draw individual sessions
      DrawSessionBox("Tokyo_" + IntegerToString(i), TokyoColor, adjustedTokyoStart, adjustedTokyoEnd, dayStart);
      DrawSessionBox("London_" + IntegerToString(i), LondonColor, adjustedLondonStart, adjustedLondonEnd, dayStart);
      DrawSessionBox("NewYork_" + IntegerToString(i), NewYorkColor, adjustedNewYorkStart, adjustedNewYorkEnd, dayStart);

      // Handle overlapping sessions
      DrawOverlapBox("Tokyo_London_Overlap_" + IntegerToString(i), OverlapColor, adjustedTokyoStart, adjustedTokyoEnd, adjustedLondonStart, adjustedLondonEnd, dayStart);
      DrawOverlapBox("London_NewYork_Overlap_" + IntegerToString(i), OverlapColor, adjustedLondonStart, adjustedLondonEnd, adjustedNewYorkStart, adjustedNewYorkEnd, dayStart);
     }

   lastUpdateDay = iTime(Symbol(), PERIOD_D1, 0); // Track the last updated day
  }

//+------------------------------------------------------------------+
//| Adjust Time for DST                                              |
//+------------------------------------------------------------------+
int TimeDSTAdjustment()
  {
   datetime now = TimeCurrent();
   int adjustment = 0;
   if (now >= DSTStart && now <= DSTEnd)
      adjustment = 1; // Add one hour during DST
   return adjustment;
  }

//+------------------------------------------------------------------+
//| Draw Session Background Box                                      |
//+------------------------------------------------------------------+
void DrawSessionBox(string sessionName, color sessionColor, int startHour, int endHour, datetime dayStart)
  {
   datetime sessionStart = dayStart + startHour * 3600;
   datetime sessionEnd = dayStart + endHour * 3600;
   
   double highestPrice = WindowPriceMax(); // Top of the chart
   double lowestPrice = WindowPriceMin();  // Bottom of the chart

   string boxName = sessionName + "_Box";
   if (ObjectFind(0, boxName) < 0)
     {
      ObjectCreate(0, boxName, OBJ_RECTANGLE, 0, sessionStart, highestPrice, sessionEnd, lowestPrice);
      ObjectSetInteger(0, boxName, OBJPROP_COLOR, sessionColor);
      ObjectSetInteger(0, boxName, OBJPROP_WIDTH, LineWidth);
      ObjectSetInteger(0, boxName, OBJPROP_BACK, true);  // Display in background
     }
   
   if (ShowLabels)
      DrawSessionLabel(sessionName, sessionStart, sessionColor);
  }

//+------------------------------------------------------------------+
//| Draw Overlapping Session Box                                     |
//+------------------------------------------------------------------+
void DrawOverlapBox(string overlapName, color overlapColor, int start1, int end1, int start2, int end2, datetime dayStart)
  {
   int overlapStart = MathMax(start1, start2); // Start of overlap
   int overlapEnd = MathMin(end1, end2);       // End of overlap

   // Only draw if overlap exists
   if (overlapStart < overlapEnd)
     {
      datetime overlapStartTime = dayStart + overlapStart * 3600;
      datetime overlapEndTime = dayStart + overlapEnd * 3600;

      double highestPrice = WindowPriceMax(); // Top of the chart
      double lowestPrice = WindowPriceMin();  // Bottom of the chart

      string boxName = overlapName + "_Box";
      if (ObjectFind(0, boxName) < 0)
        {
         ObjectCreate(0, boxName, OBJ_RECTANGLE, 0, overlapStartTime, highestPrice, overlapEndTime, lowestPrice);
         ObjectSetInteger(0, boxName, OBJPROP_COLOR, overlapColor);
         ObjectSetInteger(0, boxName, OBJPROP_WIDTH, LineWidth);
         ObjectSetInteger(0, boxName, OBJPROP_BACK, true);  // Display in background
        }
     }
  }

//+------------------------------------------------------------------+
//| Draw Session Label                                               |
//+------------------------------------------------------------------+
void DrawSessionLabel(string sessionName, datetime startTime, color labelColor)
  {
   string labelName = sessionName + "_Label";
   if (ObjectFind(0, labelName) < 0)
     {
      ObjectCreate(0, labelName, OBJ_TEXT, 0, startTime, 0);
      ObjectSetText(labelName, sessionName, 10, "Arial", labelColor);
      ObjectSetInteger(0, labelName, OBJPROP_COLOR, labelColor);
     }
  }

//+------------------------------------------------------------------+
//| On Deinitialization                                              |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   RemoveSessionObjects(); // Remove all session objects
  }

//+------------------------------------------------------------------+
//| Remove All Session Objects                                       |
//+------------------------------------------------------------------+
void RemoveSessionObjects()
  {
   for (int i = 0; i < LookbackDays; i++)
     {
      ObjectDelete(0, "Tokyo_" + IntegerToString(i) + "_Box");
      ObjectDelete(0, "London_" + IntegerToString(i) + "_Box");
      ObjectDelete(0, "NewYork_" + IntegerToString(i) + "_Box");
      ObjectDelete(0, "Tokyo_" + IntegerToString(i) + "_Label");
      ObjectDelete(0, "London_" + IntegerToString(i) + "_Label");
      ObjectDelete(0, "NewYork_" + IntegerToString(i) + "_Label");
      ObjectDelete(0, "Tokyo_London_Overlap_" + IntegerToString(i) + "_Box");
      ObjectDelete(0, "London_NewYork_Overlap_" + IntegerToString(i) + "_Box");
     }
  }

//+------------------------------------------------------------------+
//| On Calculate                                                     |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
  {
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   if (currentDay != lastUpdateDay) // Check if a new day has started
     {
      RemoveSessionObjects(); // Remove old session objects
      InitializeSessions();  // Redraw sessions for the new day
     }
   return(rates_total);
  }
//+------------------------------------------------------------------+
